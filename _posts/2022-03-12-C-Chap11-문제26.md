---
published: true
title: "2022-03-12-C-Chap11-문제26"
categories:
  - C
tags:
  - C
toc: true
toc_sticky: true
toc_label: "C"
---

```
비상금을 숨겨 놓는 장소를 알려줄 비밀지도를 손에 넣었다.
그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 지도는 한 변의 길이가 5인 정사각형 배열 형태로, 각 칸은 "공백:("")또는 "벽"("#")두 종류로 이루어져 있다.

전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 "지도 1"과 지도 2"라고 하자.
지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다.
지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.

"지도 1"과 "지도 2"는 각각 정수 배열로 암호화되어 있다. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화 했을 때 얻어지는 이진수에 해당하는 값의 배열이다.
```

![image](https://github.com/222SeungHyun/222SeungHyun.github.io/blob/master/_images/%EA%B8%B0%EC%B4%88%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%2010%EC%9E%A5%20%EC%8B%A4%EC%8A%B5-%EB%AC%B8%EC%A0%9C25.png?raw=true)

> **조건**

- 함수 이름은 hello_World Count로 작성한다.
- 함수가 호출될 때마다 회수를 출력한다.
- 함수가 호출되는 회수를 저장하는 변수는 함수 내부에서 선언한다.
- 메인함수에서 반복문을 사용하여 반복문을 사용한 회수만큼 값이 나오는지 확인한다.

> **Source**

```C++
#include<stdio.h>

int hello_world_count(int a) {
	int count = 1;

	if (a > 0) {
		count += hello_world_count(a - 1);
		return count;
	}
	else
		return 1;

}

int main(void) {
	printf("Hello World Counting...\n");

	for (int i = 0; i < 15; i++) {
		printf("Hello World!\n");
		printf("%d\n", hello_world_count(i));
	}

	return 0;
}
```
